#!/usr/bin/env luajit

-- Cross-platform path setup
local function setup_paths()
    local is_windows = package.config:sub(1,1) == '\\'
    local home = os.getenv(is_windows and "USERPROFILE" or "HOME")
    local sep = is_windows and "\\" or "/"
    
    if home then
        package.path = home .. sep .. ".luarocks" .. sep .. "share" .. sep .. "lua" .. sep .. "5.1" .. sep .. "?.lua;" .. package.path
        package.path = home .. sep .. ".luarocks" .. sep .. "share" .. sep .. "lua" .. sep .. "5.1" .. sep .. "?" .. sep .. "init.lua;" .. package.path
        
        if is_windows then
            package.cpath = home .. sep .. ".luarocks" .. sep .. "lib" .. sep .. "lua" .. sep .. "5.1" .. sep .. "?.dll;" .. package.cpath
        else
            package.cpath = home .. sep .. ".luarocks" .. sep .. "lib" .. sep .. "lua" .. sep .. "5.1" .. sep .. "?.so;" .. package.cpath
        end
    end
end

setup_paths()

-- Resolve project root relative to this script
local script_path = debug.getinfo(1, "S").source:sub(2)
local script_dir = script_path:match("(.*/)")

-- Add project root to package.path
package.path =
    script_dir .. "../?.lua;" ..
    script_dir .. "../?/init.lua;" ..
    package.path

local socket = require('socket')
local pgec = require('pgec')
local bit = require('bit')
local crypto = require('pgec.crypto')
local protocol = require('pgec.protocol')

print([[
╔═══════════════════════════════════════╗
║     PGEC Client v1.0                  ║
║     Multi-User Support                ║
╚═══════════════════════════════════════╝
]])

-- Cross-platform user scanning
local function scan_users_simple()
    local users = {}
    
    -- Try different methods based on OS
    local is_windows = package.config:sub(1,1) == '\\'
    
    if is_windows then
        -- Windows: use dir command
        local handle = io.popen('dir /b *_private.pem 2>nul')
        if handle then
            for file in handle:lines() do
                local name = file:match('(.+)_private%.pem$')
                if name then
                    local public_file = name .. '_public.pem'
                    local f = io.open(public_file, 'r')
                    if f then
                        f:close()
                        table.insert(users, {
                            name = name,
                            private_key = file,
                            public_key = public_file
                        })
                    end
                end
            end
            handle:close()
        end
    else
        -- Unix/Linux/macOS: use ls command
        local handle = io.popen('ls *_private.pem 2>/dev/null')
        if handle then
            for file in handle:lines() do
                local name = file:match('(.+)_private%.pem$')
                if name then
                    local public_file = name .. '_public.pem'
                    local f = io.open(public_file, 'r')
                    if f then
                        f:close()
                        table.insert(users, {
                            name = name,
                            private_key = file,
                            public_key = public_file
                        })
                    end
                end
            end
            handle:close()
        end
    end
    
    -- Fallback: manual check for common names
    if #users == 0 then
        local common_users = {'jigsaw', 'alice', 'bob', 'carol', 'dave', 'eve', 'sigma'}
        
        for _, name in ipairs(common_users) do
            local private_file = name .. '_private.pem'
            local public_file = name .. '_public.pem'
            
            local f = io.open(private_file, 'r')
            if f then
                f:close()
                local f2 = io.open(public_file, 'r')
                if f2 then
                    f2:close()
                    table.insert(users, {
                        name = name,
                        private_key = private_file,
                        public_key = public_file
                    })
                end
            end
        end
    end
    
    return users
end

local Client = {}
Client.__index = Client

function Client.new(host, port)
    local self = setmetatable({}, Client)
    
    self.host = host or 'localhost'
    self.port = port or 9110
    self.sock = nil
    self.connected = false
    
    -- Client state
    self.uuid = crypto.generate_uuid_v7()
    self.private_key = nil
    self.public_key = nil
    self.username = nil
    self.aes_key = nil
    self.session_key = nil
    
    -- Trust index
    self.trust_index = {}
    
    return self
end

function Client:load_keys(private_path, public_path)
    local f = io.open(private_path, 'r')
    if not f then
        print("Error: " .. private_path .. " not found!")
        return false
    end
    self.private_key = f:read('*all')
    f:close()
    
    f = io.open(public_path, 'r')
    if not f then
        print("Error: " .. public_path .. " not found!")
        return false
    end
    self.public_key = f:read('*all')
    f:close()
    
    return true
end

function Client:connect()
    print(string.format("Connecting to %s:%d...", self.host, self.port))
    
    self.sock = socket.tcp()
    self.sock:settimeout(10)
    
    local ok, err = self.sock:connect(self.host, self.port)
    if not ok then
        print("Connection failed:", err)
        return false
    end
    
    -- WebSocket handshake
    local handshake = table.concat({
        "GET / HTTP/1.1",
        "Host: " .. self.host .. ":" .. self.port,
        "Upgrade: websocket",
        "Connection: Upgrade",
        "Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==",
        "Sec-WebSocket-Protocol: pgec",
        "Sec-WebSocket-Version: 13",
        "",
        ""
    }, "\r\n")
    
    self.sock:send(handshake)
    
    -- Read response
    local response = self.sock:receive('*l')
    if not response or not response:match("101") then
        print("WebSocket handshake failed")
        return false
    end
    
    -- Skip remaining handshake headers
    while true do
        local line = self.sock:receive('*l')
        if not line or line == "" then
            break
        end
    end
    
    self.connected = true
    print("✅ Connected!")
    return true
end

function Client:send_ws_frame(message)
    local len = #message
    local frame
    
    if len < 126 then
        frame = string.char(0x81, len) .. message
    else
        frame = string.char(0x81, 126) .. string.char(
            math.floor(len / 256),
            len % 256
        ) .. message
    end
    
    self.sock:send(frame)
end

function Client:receive_ws_frame()
    local header = self.sock:receive(2)
    if not header then
        return nil
    end
    
    local b1, b2 = header:byte(1, 2)
    local opcode = bit.band(b1, 0x0F)
    
    if opcode ~= 0x01 then
        return nil
    end
    
    local len = bit.band(b2, 0x7F)
    
    if len == 126 then
        local len_bytes = self.sock:receive(2)
        if not len_bytes then return nil end
        len = len_bytes:byte(1) * 256 + len_bytes:byte(2)
    elseif len == 127 then
        return nil
    end
    
    local payload = self.sock:receive(len)
    return payload
end

function Client:send_hello()
    print("\nSending hello...")
    
    local signature = crypto.sign('PGEC_HANDSHAKE', self.private_key)
    local hello_msg = protocol.build('hello', {
        value = self.uuid,
        key = self.public_key,
        sig = signature
    })
    
    self:send_ws_frame(hello_msg)
    
    local response = self:receive_ws_frame()
    if not response then
        print("No response to hello")
        return false
    end
    
    local cmd = protocol.parse(response)
    if cmd and cmd.command == 'hi' then
        print("✅ Handshake complete!")
        return true
    end
    
    print("❌ Handshake failed")
    return false
end

function Client:login(username, password)
    print(string.format("\nLogging in as '%s'...", username))
    
    local f = io.open('server_public.pem', 'r')
    if not f then
        print("Error: server_public.pem not found!")
        return false
    end
    local server_pubkey = f:read('*all')
    f:close()
    
    local creds = username .. 'P' .. password
    local encrypted = crypto.encrypt_rsa(creds, server_pubkey)
    local sig = crypto.sign(self.uuid, self.private_key)
    
    local login_msg = protocol.build('login', {
        value = encrypted,
        id = self.uuid,
        sig = sig
    })
    
    self:send_ws_frame(login_msg)
    
    -- Wait for welcome (may receive index first)
    local max_attempts = 5
    for i = 1, max_attempts do
        local response = self:receive_ws_frame()
        if not response then
            print("No response to login")
            return false
        end
        
        local cmd = protocol.parse(response)
        
        if cmd and cmd.command == 'index' then
            self:handle_index(cmd.params)
            
        elseif cmd and cmd.command == 'welcome' then
            self.username = cmd.params.value
            self.aes_key = crypto.decrypt_rsa(cmd.params.aes, self.private_key)
            self.session_key = crypto.decrypt_rsa(cmd.params.ses, self.private_key)
            
            print("✅ Logged in as " .. self.username .. "!")
            return true
        end
    end
    
    print("❌ Login failed")
    return false
end

function Client:handle_index(params)
    local signed_username = params.value
    local device_id = params.id
    
    self.trust_index[device_id] = {
        signed_username = signed_username
    }
    
    print(string.format("[SYSTEM] User joined (ID: %s)", device_id:sub(1, 8)))
end

function Client:send_message(text)
    if not self.aes_key then
        print("Not logged in!")
        return
    end
    
    local encrypted = crypto.encrypt_aes(text, self.aes_key)
    local signed_username = crypto.sign(self.username, self.private_key)
    
    local send_msg = protocol.build('send', {
        value = encrypted,
        u = signed_username,
        id = self.uuid,
        ses = self.session_key
    })
    
    self:send_ws_frame(send_msg)
end

function Client:receive_message()
    local response = self:receive_ws_frame()
    if not response then
        return nil
    end
    
    local cmd = protocol.parse(response)
    if not cmd then
        return nil
    end
    
    if cmd.command == 'receive' then
        local encrypted_msg = cmd.params.value
        local sender_id = cmd.params.id
        
        local decrypted = crypto.decrypt_aes(encrypted_msg, self.aes_key)
        
        if decrypted then
            local short_id = sender_id:sub(1, 8)
            print(string.format("\n[%s] %s", short_id, decrypted))
            io.write("> ")
            io.flush()
            return decrypted
        end
        
    elseif cmd.command == 'index' then
        self:handle_index(cmd.params)
        io.write("> ")
        io.flush()
        
    elseif cmd.command == 'bye' then
        print("\n[SYSTEM] Server rotation! Disconnecting...")
        return 'bye'
        
    elseif cmd.command == 'fuck' then
        print("\n[SYSTEM] You have been banned!")
        return 'fuck'
        
    elseif cmd.command == 'wait' then
        print("\n[SYSTEM] Rate limited! Slow down!")
        io.write("> ")
        io.flush()
    end
    
    return nil
end

function Client:interactive()
    print("\n" .. string.rep("=", 50))
    print("Chat Active - Type messages and press Enter")
    print("Commands: /quit, /help, /users")
    print(string.rep("=", 50) .. "\n")
    
    self.sock:settimeout(0.01)
    
    while self.connected do
        io.write("> ")
        io.flush()
        
        -- Poll for messages while waiting for input
        local start = socket.gettime()
        while socket.gettime() - start < 60 do
            local msg = self:receive_message()
            if msg == 'bye' or msg == 'fuck' then
                return
            end
            socket.sleep(0.05)
        end
        
        -- Read user input
        local line = io.read()
        
        if line then
            if line == '/quit' then
                print("Goodbye!")
                break
            elseif line == '/help' then
                print("\nCommands:")
                print("  /quit   - Exit")
                print("  /help   - Show this help")
                print("  /users  - List connected users")
            elseif line == '/users' then
                print("\nConnected users:")
                local count = 0
                for device_id, info in pairs(self.trust_index) do
                    count = count + 1
                    print(string.format("  %d. %s", count, device_id:sub(1, 8)))
                end
                if count == 0 then
                    print("  (none)")
                end
            elseif line ~= "" then
                self:send_message(line)
            end
        end
    end
end

-- Main
local function main()
    print("\nScanning for user keypairs...")
    local users = scan_users_simple()
    
    if #users == 0 then
        print("\n❌ No user keypairs found!")
        print("\nCreate a user first:")
        print("\n./bin/pgec-user")
        print("\nIf you are connecting to a remote server that you don't even own, Don't even try, pgec-ws is NOT ready for prod setups!")
        return
    end
    
    print("\nAvailable users:")
    for i, user in ipairs(users) do
        print(string.format("  %d. %s", i, user.name))
    end
    
    print("\nSelect user (1-" .. #users .. "): ")
    local choice = tonumber(io.read())
    
    if not choice or choice < 1 or choice > #users then
        print("Invalid choice")
        return
    end
    
    local selected_user = users[choice]
    print("Selected: " .. selected_user.name)
    
    local client = Client.new('localhost', 9110)
    
    print("\nLoading keys...")
    if not client:load_keys(selected_user.private_key, selected_user.public_key) then
        return
    end
    print("✅ Keys loaded")
    
    if not client:connect() then
        return
    end
    
    if not client:send_hello() then
        return
    end
    
    print("\nUsername: ")
    local username = io.read()
    print("Password: ")
    local password = io.read()
    
    if not client:login(username, password) then
        return
    end
    
    client:interactive()
    
    if client.sock then
        client.sock:close()
    end
end

main()
